<% if (flow) { %>// @flow
<% } %>import * as ActionType from './<%= Name %>.actionTypes';
<% if (flow) { %>import { <%= Name %> } from './<%= Name %>.record';
<% } %>import { get<%= Name %>Key, recordToDto, listQueryToListQueryDto } from './<%= Name %>.utils';

/**
 * Action creators to work with <%= Name %>.
 *
 * @module <%= moduleName %>/actions
 */

/**
 * Action for load <%= Name %> by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {string} key - Some key that allow to differ 1 instance from another.
 *     It's an `id` usually.
 *
 * @returns {Action} Action with type LOAD and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>ByKey(key<% if (flow) { %>: string<% } %>) {
  return {
    type: ActionType.LOAD,
    payload: {
      <%= name %>Id: key,
    },
  };
}

/**
 * Action for mark load <%= Name %> process as finished by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {Ob} key - Some key that allow to differ 1 instance from another.
 *     It's an `id` usually.
 *
 * @returns {Action} Action with type LOAD_SUCCESS and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>ByKeySuccess(key<% if (flow) { %>: string<% } %>) {
  return {
    type: ActionType.LOAD_SUCCESS,
    payload: {
      <%= name %>Id: key,
    },
  };
}

/**
 * Action for mark load <%= Name %> process as failed by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {{ <%= name %>Id: string, error: { message: string } }} $1 - Key of <%= Name %> instance and error.
 *
 * @returns {Action} Action with type LOAD_FAILED and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>ByKeyFailed({ <%= name %>Id, error }<% if (flow) { %>: { <%= name %>Id: string, error: { message: string } }<% } %>) {
  return {
    type: ActionType.LOAD_FAILED,
    payload: {
      <%= name %>Id,
      error,
    },
  };
}

/**
 * Action for load <%= Name %> list by some query.
 *
 * Transforms argument into query's dto and try perform request.
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {Object} listQuery - Some key that allow to differ 1 instance from another.
 *
 * @returns {Object} Action with type LOAD_LIST and `{ query }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>List(listQuery<% if (flow) { %>: { [string]: mixed }<% } %>) {
  const query = listQueryToListQueryDto(listQuery);

  return {
    type: ActionType.LOAD_LIST,
    payload: {
      query,
    },
  };
}

/**
 * Action for mark load <%= Name %> list process as finished by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @returns {Action} Action with type LOAD_LIST_SUCCESS.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>ListSuccess() {
  return {
    type: ActionType.LOAD_LIST_SUCCESS,
  };
}

/**
 * Action for mark load <%= Name %> list process as failed by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @returns {Action} Action with type LOAD_LIST_FAILED.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>ListFailed(error<% if (flow) { %>: error: { message: string }<% } %>) {
  return {
    type: ActionType.LOAD_LIST_FAILED,
    payload: {
      error,
    },
  };
}

/**
 * Action for update or create <%= Name %>.
 *
 * Transforms record object into dto and try perform request.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {<%= Name %>} <%= name %> - New or updated instance of <%= Name %>.
 *     This should be a Immutable.Record.
 *
 * @returns {Object} Action with type SAVE and `{ <%= name%>Id, body }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function save<%= Name %>(<%= name %><% if (flow) { %>: <%= Name %><% } %>) {
  const key = get<%= Name %>Key(<%= name %>);
  const body = recordToDto(<%= name %>);

  return {
    type: ActionType.SAVE,
    payload: {
      <%= name %>Id: key,
      <%= name %>: body,
    },
  };
}

/**
 * Action for mark save <%= Name %> process as finished by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {Ob} key - Some key that allow to differ 1 instance from another.
 *     It's an `id` usually.
 *
 * @returns {Action} Action with type SAVE_SUCCESS and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function save<%= Name %>Success(key<% if (flow) { %>: string<% } %>) {
  return {
    type: ActionType.SAVE_SUCCESS,
    payload: {
      <%= name %>Id: key,
    },
  };
}

/**
 * Action for mark save <%= Name %> process as failed by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {{ <%= name %>Id: string, error: { message: string } }} $1 - Key of <%= Name %> instance and error.
 *
 * @returns {Action} Action with type SAVE_FAILED and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function load<%= Name %>yFailed({ <%= name %>Id, error }<% if (flow) { %>: { <%= name %>Id: string, error: { message: string } }<% } %>) {
  return {
    type: ActionType.SAVE_FAILED,
    payload: {
      <%= name %>Id,
      error,
    },
  };
}

/**
 * Action for delete <%= Name %> by key.
 *
 * Transforms record object into dto and try perform request.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {string} key - Some key that allow to differ 1 instance from another.
 *     It's an `id` usually.
 *
 * @returns {Object} Action with type DELETE and `{ <%= name%>Id }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function delete<%= Name %>ByKey(key<% if (flow) { %>: string<% } %>) {
  return {
    type: ActionType.DELETE,
    payload: {
      <%= name%>Id: key,
    },
  };
}

/**
 * Action for mark delete <%= Name %> process as finished by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {Ob} key - Some key that allow to differ 1 instance from another.
 *     It's an `id` usually.
 *
 * @returns {Action} Action with type DELETE_SUCCESS and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function delete<%= Name %>ByKeySuccess(key<% if (flow) { %>: string<% } %>) {
  return {
    type: ActionType.DELETE_SUCCESS,
    payload: {
      <%= name %>Id: key,
    },
  };
}

/**
 * Action for mark delete <%= Name %> process as failed by its key.
 *
 * Real request performing is optional.
 * Code that start request is placed in <%= Name %>.sagas.js.
 * Request's code is placed in <%= Name %>.api.js file.
 *
 * @param {{ <%= name %>Id: string, error: { message: string } }} $1 - Key of <%= Name %> instance and error.
 *
 * @returns {Action} Action with type DELETE_FAILED and `{ <%= name %>Id: key }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function delete<%= Name %>ByKeyFailed({ <%= name %>Id, error }<% if (flow) { %>: { <%= name %>Id: string, error: { message: string } }<% } %>) {
  return {
    type: ActionType.DELETE_FAILED,
    payload: {
      <%= name %>Id,
      error,
    },
  };
}

/**
 * Action for delete instance of <%= Name %>.
 *
 * See delete<%= Name %>.
 *
 * @param {<%= Name %>} <%= name %> - Instance of <%= Name %> to delete.
 *     This should be a Immutable.Record.
 *
 * @returns {Object} see delete<%= Name %>.
 * @memberof <%= moduleName %>/actions
 */
export function delete<%= Name %>(<%= name %><% if (flow) { %>: <%= Name %><% } %>) {
  const key = get<%= Name %>Key(<%= name %>);

  return delete<%= Name %>ByKey(key);
}

/**
 * Action for set <%= Name %> record inside the store.
 *
 * @param {Object} $1 - Params for action.
 * @param {<%= Name %>} $1.<%= name %> - Instance of <%= Name %> to set.
 *     This should be a Immutable.Record.
 * @param {number} $1.time - Time that action called.
 *
 * @returns {Object} Action with type SET and `{ <%= name %>, time }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function set<%= Name %>({ <%= name %>, time }<% if (flow) { %>: { <%= name %>: <%= Name %>, time: number }<% } %>) {
  return {
    type: ActionType.SET,
    payload: {
      <%= name %>,
      time,
    },
  };
}

/**
 * Action for set <%= Name %> record inside the store.
 *
 * @param {Object} $1 - Params for action.
 * @param {Array<<%= Name %>>} $1.<%= name %>List - Array of instances of <%= Name %> to set.
 *     Every item should be a Immutable.Record.
 * @param {number} $1.time - Time that action called.
 *
 * @returns {Object} Action with type SET_LIST and `{ <%= name %>List, time }` as payload.
 * @memberof <%= moduleName %>/actions
 */
export function set<%= Name %>({ <%= name %>List, time }<% if (flow) { %>: { <%= name %>List: Array<<%= Name %>>, time: number }<% } %>) {
  return {
    type: ActionType.SET_LIST,
    payload: {
      <%= name %>List,
      time,
    },
  };
}
